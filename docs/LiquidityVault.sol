// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./interfaces/IAmadeusOracle.sol"; // Connects to Off-chain Nova Agent

/**
 * @title Amadeus Liquidity Vault
 * @dev Autonomous lending pool for Travel Agencies.
 * Integrates with Amadeus zk-Verify Oracle for risk validation.
 */
contract LiquidityVault is ReentrancyGuard {
    
    // --- Constants ---
    uint256 public constant MIN_COLLATERAL_RATIO = 120; // 120%
    uint256 public constant INTEREST_RATE_BPS = 250;    // 2.5% fixed fee
    
    // --- Interfaces ---
    IAmadeusOracle public amadeusOracle;
    
    // --- Events ---
    event LiquidityCrunchDetected(string indexed agencyId, uint256 gapAmount);
    event LoanDisbursed(string indexed agencyId, uint256 amount, uint256 timestamp);
    event LoanRepaid(string indexed agencyId, uint256 amount);

    struct Loan {
        uint256 amount;
        uint256 dueDate;
        bool active;
        bytes32 pnrHash; // Hash of the tickets used as collateral
    }

    mapping(string => Loan) public agencyLoans;

    constructor(address _oracleAddress) {
        amadeusOracle = IAmadeusOracle(_oracleAddress);
    }

    /**
     * @notice Requests liquidity based on validated future bookings
     * @param agencyId The IATA ID of the agency
     * @param amountRequested Amount of USDC needed
     * @param proofOfSales zk-Proof generated by Nova Agent confirming valid PNRs
     */
    function requestLiquidity(
        string memory agencyId, 
        uint256 amountRequested, 
        bytes memory proofOfSales
    ) external nonReentrant {
        
        // 1. Verify specific Travel-Factoring logic via Oracle
        // The Oracle verifies that the PNRs exist and are confirmed in Amadeus GDS
        (bool isValid, uint256 receivableValue, uint256 riskScore) = 
            amadeusOracle.verifyProofOfSales(proofOfSales);

        require(isValid, "Invalid Amadeus Proof");
        require(riskScore < 50, "Portfolio Risk too high"); // Score 0-100

        // 2. Check Collateral Ratio (120%)
        uint256 ratio = (receivableValue * 100) / amountRequested;
        require(ratio >= MIN_COLLATERAL_RATIO, "Insufficient Collateral Ratio");

        emit LiquidityCrunchDetected(agencyId, amountRequested);

        // 3. Update State & Disburse
        agencyLoans[agencyId] = Loan({
            amount: amountRequested,
            dueDate: block.timestamp + 30 days,
            active: true,
            pnrHash: keccak256(proofOfSales)
        });

        // (Internal logic to transfer tokens would go here)
        emit LoanDisbursed(agencyId, amountRequested, block.timestamp);
    }
}
